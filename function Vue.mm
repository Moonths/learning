{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"5T549","rootPoint":{"objectClass":"CGPoint","x":360,"y":3783.875},"children":{"0":{"objectClass":"MindNode","ID":"885RD","children":{"0":{"objectClass":"MindNode","ID":"8T46V","text":"Vue.prototype._init = function"},"1":{"objectClass":"MindNode","ID":"919NX","children":{"0":{"objectClass":"MindNode","ID":"UM825","children":{"0":{"objectClass":"MindNode","ID":"UQ0H2","text":"initInternalComponent(vm, options)\n将组件配置对象上的一些深层次属性放到 vm.$options 选项中"},"objectClass":"NSArray"},"text":"if 子组件"},"1":{"objectClass":"MindNode","ID":"RP6EX","children":{"0":{"objectClass":"MindNode","ID":"8EAMF","children":{"0":{"objectClass":"MindNode","ID":"3H38J","text":"resolveConstructorOptions\n从组件构造函数中解析配置对象 options，并合并基类选项"},"1":{"objectClass":"MindNode","ID":"8MBH8","text":"mergeOptions\n合并两个选项，出现相同配置项时，子选项会覆盖父选项的配置"},"objectClass":"NSArray"},"text":"     vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n合并选项","maxWidthLine":318.046875},"objectClass":"NSArray"},"text":"if 根组件"},"2":{"objectClass":"MindNode","ID":"SJ2O3","text":"initLifecycle(vm)\n初始化组件实例关系属性，比如 $parent、$children、$root、$refs 等"},"3":{"objectClass":"MindNode","ID":"J3H05","text":" initEvents(vm)\n初始化自定义事件，这里需要注意一点，所以我们在 <comp @click=\"handleClick\" /> 上注册的事件，监听者不是父组件，"},"4":{"objectClass":"MindNode","ID":"M9GGL","text":"initRender(vm)\n解析组件的插槽信息，得到 vm.$slot，处理渲染函数，得到 vm.$createElement 方法，即 h 函数"},"5":{"objectClass":"MindNode","ID":"YCQ17","text":" callHook(vm, 'beforeCreate')\n调用 beforeCreate 钩子函数"},"6":{"objectClass":"MindNode","ID":"4PF28","children":{"0":{"objectClass":"MindNode","ID":"S7825","text":"resolveInject"},"objectClass":"NSArray"},"text":"initInjections(vm)\n初始化组件的 inject 配置项，得到 result[key] = val 形式的配置对象，然后对结果数据进行响应式处理，并代理每个 key 到 vm 实例（在处理data/prop之前完成）"},"7":{"objectClass":"MindNode","ID":"3GJY6","children":{"0":{"objectClass":"MindNode","ID":"C31H0","children":{"0":{"objectClass":"MindNode","ID":"B3TM9","children":{"0":{"objectClass":"MindNode","ID":"CBT4N","text":"遍历 props 对象"},"1":{"objectClass":"MindNode","ID":"NMK21","text":"缓存 key"},"2":{"objectClass":"MindNode","ID":"1K5IO","text":"获取 props[key] 的默认值"},"3":{"objectClass":"MindNode","ID":"O06P5","text":"props 的每个 key 设置数据响应式"},"4":{"objectClass":"MindNode","ID":"422OK","children":{"0":{"objectClass":"MindNode","ID":"72LRF","text":"设置代理，将 key 代理到 target 上"},"objectClass":"NSArray"},"text":"代理 key 到 vm 对象上"},"objectClass":"NSArray"},"text":" 处理 props 对象，为 props 对象的每个属性设置响应式，并将其代理到 vm 实例上"},"1":{"objectClass":"MindNode","ID":"I2Y73","children":{"0":{"objectClass":"MindNode","ID":"7BR3H","text":" 获取 props 配置项\n  const props = vm.$options.props"},"1":{"objectClass":"MindNode","ID":"WC4YW","text":"遍历 methods 对象"},"objectClass":"NSArray"},"text":"处理 methos 对象，校验每个属性的值是否为函数、和 props 属性比对进行判重处理，最后得到 vm[key] = methods[key]"},"2":{"objectClass":"MindNode","ID":"5Z5FY","children":{"0":{"objectClass":"MindNode","ID":"2O7SP","children":{"0":{"objectClass":"MindNode","ID":"Q738Q","text":"非对象和 VNode 实例不做响应式处理"},"1":{"objectClass":"MindNode","ID":"6CNMG","text":"如果 value 对象上存在 __ob__ 属性，则表示已经做过观察了，直接返回 __ob__ 属性"},"2":{"objectClass":"MindNode","ID":"1223U","children":{"0":{"objectClass":"MindNode","ID":"D55MN","text":"实例话一个 dep"},"1":{"objectClass":"MindNode","ID":"6HTVT","text":"在 value 对象上设置 __ob__ 属性"},"2":{"objectClass":"MindNode","ID":"G4MNI","children":{"0":{"objectClass":"MindNode","ID":"01X5O","text":""},"objectClass":"NSArray"},"text":"  IF    * value 为数组\n       * hasProto = '__proto__' in {}\n       * 用于判断对象是否存在 __proto__ 属性，通过 obj.__proto__ 可以访问对象的原型链\n       * 但由于 __proto__ 不是标准属性，所以有些浏览器不支持，比如 IE6-10，Opera10.1\n       * 为什么要判断，是因为一会儿要通过 __proto__ 操作数据的原型链\n       * 覆盖数组默认的七个原型方法，以实现数组响应式\n调用observeArray() （遍历数组 调用 observe(items[i])）","maxWidthLine":459},"3":{"objectClass":"MindNode","ID":"7PQ08","children":{"0":{"objectClass":"MindNode","ID":"364P1","children":{"0":{"objectClass":"MindNode","ID":"C6120","children":{"0":{"objectClass":"MindNode","ID":"8T8DV","children":{"0":{"objectClass":"MindNode","ID":"3X2R6","children":{"0":{"objectClass":"MindNode","ID":"0K9KH","text":"属性：subs:[watcher的实例]（存储依赖列表）\n         notify() （通知更新）\n方法：depend() （添加依赖）\n         notify() （通知更新）"},"1":{"objectClass":"MindNode","ID":"0T140","text":""},"objectClass":"NSArray"},"text":"Dep(收集依赖)"},"1":{"objectClass":"MindNode","ID":"P85G4","children":{"0":{"objectClass":"MindNode","ID":"3496O","text":"属性：target（目标对象）\n         expression（对象的属性名）\n         callback（触发更新时的回调）\n         value（对象的值）\n方法：update （对象的更新）\n         get（获取对象的值）"},"1":{"objectClass":"MindNode","ID":"5U23K","text":""},"objectClass":"NSArray"},"text":"Watcher（触发依赖更新）"},"objectClass":"NSArray"},"text":" * 一个 dep 对应一个 obj.key\n * 在读取响应式数据时，负责收集依赖，每个 dep（或者说 obj.key）依赖的 watcher 有哪些\n * 在响应式数据更新时，负责通知 dep 中那些 watcher 去执行 update 方法\n */"},"objectClass":"NSArray"},"text":"实例化 dep，一个 key 一个 dep"},"1":{"objectClass":"MindNode","ID":"G14G8","text":"获取 obj[key] 的属性描述符，发现它是不可配置对象的话直接 return"},"2":{"objectClass":"MindNode","ID":"XEZPR","text":"记录 getter 和 setter，获取 val 值"},"3":{"objectClass":"MindNode","ID":"TU731","text":"递归调用，处理 val 即 obj[key] 的值为对象的情况，保证对象中的所有 key 都被观察"},"4":{"objectClass":"MindNode","ID":"VRN61","children":{"0":{"objectClass":"MindNode","ID":"63744","lineColor":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"D7FNI","text":"dep.depend()"},"1":{"objectClass":"MindNode","ID":"WU568","children":{"0":{"objectClass":"MindNode","ID":"KS7U4","children":{"0":{"objectClass":"MindNode","ID":"8T7M1","children":{"0":{"objectClass":"MindNode","ID":"4PA25","children":{"0":{"objectClass":"MindNode","ID":"54G5Y","children":{"0":{"objectClass":"MindNode","ID":"V576W","children":{"0":{"objectClass":"MindNode","ID":"5P3BM","children":{"0":{"objectClass":"MindNode","ID":"088B9","children":{"0":{"objectClass":"MindNode","ID":"941UM","children":{"0":{"objectClass":"MindNode","ID":"31FUT","children":{"0":{"objectClass":"MindNode","ID":"55N7B","children":{"0":{"objectClass":"MindNode","ID":"74BO7","text":" * 做了三件事：\n *   1、将 pending 置为 false\n *   2、清空 callbacks 数组\n *   3、执行 callbacks 数组中的每一个函数（比如 flushSchedulerQueue、用户调用 nextTick 传递的回调函数）\n */"},"1":{"objectClass":"MindNode","ID":"3S1C3","children":{"0":{"objectClass":"MindNode","ID":"NH872","children":{"0":{"objectClass":"MindNode","ID":"NU486","children":{"0":{"objectClass":"MindNode","ID":"9V8MO","children":{"0":{"objectClass":"MindNode","ID":"8376K","text":"Vue.nextTick 或者 vm.$nextTick 的原理其实很简单，就做了两件事：\n将传递的回调函数用 try catch 包裹然后放入 callbacks 数组\n执行 timerFunc 函数，在浏览器的异步任务队列放入一个刷新 callbacks 数组的函数"},"objectClass":"NSArray"},"text":"Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。\n当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。\n然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。\n如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。\nflushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。\nflushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。"},"objectClass":"NSArray"},"text":" * 由 刷新队列函数 flushSchedulerQueue 调用，如果是同步 watch，则由 this.update 直接调用，完成如下几件事：\n *   1、执行实例化 watcher 传递的第二个参数，updateComponent 或者 获取 this.xx 的一个函数(parsePath 返回的函数)\n *   2、更新旧值为新值\n *   3、执行实例化 watcher 时传递的第三个参数，比如用户 watcher 的回调函数\n */"},"objectClass":"NSArray"},"text":"/ 执行 watcher.run，最终触发更新函数，比如 updateComponent 或者 获取 this.xx（xx 为用户 watch 的第二个参数），当然第二个参数也有可能是一个函数，那就直接执行\n    watcher.run()"},"objectClass":"NSArray"},"text":"flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数\n\n * flushSchedulerQueue刷新队列，由 flushCallbacks 函数负责调用，主要做了如下两件事：\n *   1、更新 flushing 为 ture，表示正在刷新队列，在此期间往队列中 push 新的 watcher 时需要特殊处理（将其放在队列的合适位置）\n *   2、按照队列中的 watcher.id 从小到大排序，保证先创建的 watcher 先执行，也配合 第一步\n *   3、遍历 watcher 队列，依次执行 watcher.before、watcher.run，并清除缓存的 watcher\n */"},"objectClass":"NSArray"},"text":"flushCallbacks()"},"objectClass":"NSArray"},"text":"首选 Promise.resolve().then(flushCallbacks)\nMutationObserver 次之\n再就是 setImmediate，它其实已经是一个宏任务了，但仍然比 setTimeout 要好\n最后没办法，则使用 setTimeout"},"objectClass":"NSArray"},"text":"可以看到 timerFunc 的作用很简单，就是将 flushCallbacks 函数放入浏览器的异步任务队列中"},"objectClass":"NSArray"},"text":"timerFunc()"},"objectClass":"NSArray"},"text":" * 完成两件事：\n *   1、用 try catch 包装 flushSchedulerQueue 函数，然后将其放入 callbacks 数组\n *   2、如果 pending 为 false，表示现在浏览器的任务队列中没有 flushCallbacks 函数\n *     如果 pending 为 true，则表示浏览器的任务队列中已经被放入了 flushCallbacks 函数，\n *     待执行 flushCallbacks 函数时，pending 会被再次置为 false，表示下一个 flushCallbacks 函数可以进入\n *     浏览器的任务队列了\n * pending 的作用：保证在同一时刻，浏览器的任务队列中只有一个 flushCallbacks 函数"},"objectClass":"NSArray"},"text":"将 watcher 放入 watcher 队列 \n从队列末尾开始倒序遍历，根据当前 watcher.id 找到它大于的 watcher.id 的位置，然后将自己插入到该位置之后的下一个位置\n即将当前 watcher 放入已排序的队列中，且队列仍是有序的\n    * 熟悉的 nextTick => vm.$nextTick、Vue.nextTick\n       *   1、将 回调函数（flushSchedulerQueue） 放入 callbacks 数组\n       *   2、通过 pending 控制向浏览器任务队列中添加 flushCallbacks 函数\n       */\n      nextTick(flushSchedulerQueue)"},"objectClass":"NSArray"},"text":"queueWatcher()"},"objectClass":"NSArray"},"text":" * 根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher\n */\nupdate () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    // 懒执行时走这里，比如 computed\n    // 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果\n    this.dirty = true\n  } else if (this.sync) {\n    // 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项，\n    // 当为 true 时在数据更新时该 watcher 就不走异步更新队列，直接执行 this.run \n    // 方法进行更新\n    // 这个属性在官方文档中没有出现\n    this.run()\n  } else {\n    // 更新时一般都这里，将 watcher 放入 watcher 队列\n    queueWatcher(this)\n  }\n}"},"objectClass":"NSArray"},"text":"update()"},"objectClass":"NSArray"},"text":" * 通知 dep 中的所有 watcher，执行 watcher.update() 方法\n */\nnotify () {\n  // stabilize the subscriber list first\n  const subs = this.subs.slice()\n  // 遍历 dep 中存储的 watcher，执行 watcher.update()\n  for (let i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}"},"objectClass":"NSArray"},"text":"dep.notify()"},"objectClass":"NSArray"},"text":"Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    // get 拦截对 obj[key] 的读取操作\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      /**\n       * Dep.target 为 Dep 类的一个静态属性，值为 watcher，在实例化 Watcher 时会被设置\n       * 实例化 Watcher 时会执行 new Watcher 时传递的回调函数（computed 除外，因为它懒执行）\n       * 而回调函数中如果有 vm.key 的读取行为，则会触发这里的 读取 拦截，进行依赖收集\n       * 回调函数执行完以后又会将 Dep.target 设置为 null，避免这里重复收集依赖\n       */\n      if (Dep.target) {\n        // 依赖收集，在 dep 中添加 watcher，也在 watcher 中添加 dep\n        dep.depend()\n        // childOb 表示对象中嵌套对象的观察者对象，如果存在也对其进行依赖收集\n        if (childOb) {\n          // 这就是 this.key.chidlKey 被更新时能触发响应式更新的原因\n          childOb.dep.depend()\n          // 如果是 obj[key] 是 数组，则触发数组响应式\n          if (Array.isArray(value)) {\n            // 为数组项为对象的项添加依赖\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    // set 拦截对 obj[key] 的设置操作\n    set: function reactiveSetter (newVal) {\n      // 旧的 obj[key]\n      const value = getter ? getter.call(obj) : val\n      // 如果新老值一样，则直接 return，不跟新更不触发响应式更新过程\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      // setter 不存在说明该属性是一个只读属性，直接 return\n      // #7981: for accessor properties without setter\n      if (getter && !setter) return\n      // 设置新值\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      // 对新值进行观察，让新值也是响应式的\n      childOb = !shallow && observe(newVal)\n      // 依赖通知更新\n      dep.notify()\n    }\n  })\n}\n"},"objectClass":"NSArray"},"text":"执行Object.defineProperty"},"objectClass":"NSArray"},"text":"defineReactive（）"},"objectClass":"NSArray"},"text":"ELSE  value 为对象，为对象的每个属性（包括嵌套对象）设置响应式 \n执行 walk()方法 （遍历对象 调用defineReactive(obj, keys[i])）"},"objectClass":"NSArray"},"text":"创建观察者实例\nob = new Observer(value)"},"objectClass":"NSArray"},"text":"observe()\n响应式处理的真正入口\n * 为对象创建观察者实例，如果对象已经被观察过，则返回已有的观察者实例，否则创建新的观察者实例"},"objectClass":"NSArray"},"text":"处理data对象\n  * 做了三件事\n   *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同\n   *   2、代理 data 对象上的属性到 vm 实例\n   *   3、为 data 对象的上数据设置响应式 \n   */"},"3":{"objectClass":"MindNode","ID":"Q40JL","children":{"0":{"objectClass":"MindNode","ID":"8L87K","children":{"0":{"objectClass":"MindNode","ID":"8PJWH","text":"获取 key 对应的值，即 getter 函数"},"objectClass":"NSArray"},"text":"遍历 computed 对象"},"1":{"objectClass":"MindNode","ID":"V3EJL","text":"为 computed 属性创建 watcher 实例"},"2":{"objectClass":"MindNode","ID":"5NX3Y","text":" 代理computed 对象中的属性到 vm 实例\n 这样就可以使用 vm.computedKey 访问计算属性了（ 非生产环境有一个判重处理，computed 对象中的属性不能和 data、props 中的属性相同）"},"objectClass":"NSArray"},"text":"处理computed对象\n   * 三件事：\n   *   1、为 computed[key] 创建 watcher 实例，默认是懒执行\n   *   2、代理 computed[key] 到 vm 实例\n   *   3、判重，computed 中的 key 不能和 data、props 中的属性重复\n   "},"4":{"objectClass":"MindNode","ID":"4147V","children":{"0":{"objectClass":"MindNode","ID":"5U6JN","children":{"0":{"objectClass":"MindNode","ID":"Q8D27","text":"如果 handler 为对象，则获取其中的 handler 选项的值"},"1":{"objectClass":"MindNode","ID":"6T6H3","text":"如果 hander 为字符串，则说明是一个 methods 方法，获取 vm[handler]"},"objectClass":"NSArray"},"text":"遍历 watch 对象\nhandler 为数组，遍历数组，获取其中的每一项，然后调用 createWatcher"},"1":{"objectClass":"MindNode","ID":"TCCNC","text":" * 创建 watcher，返回 unwatch，共完成如下 5 件事：\n *   1、兼容性处理，保证最后 new Watcher 时的 cb 为函数（兼容性处理，因为用户调用 vm.$watch 时设置的 cb 可能是对象）\n *   2、标示用户 watcher（options.user 表示用户 watcher，还有渲染 watcher，即 updateComponent 方法中实例化的 watcher）\n *   3、创建 watcher 实例\n *   4、如果设置了 immediate，则立即执行一次 cb（如果用户设置了 immediate 为 true，则立即执行一次回调函数）\n *   5、返回 unwatch（返回一个 unwatch 函数，用于解除监听）"},"objectClass":"NSArray"},"text":"处理watch对象\n   * 三件事：\n   *   1、处理 watch 对象\n   *   2、为 每个 watch.key 创建 watcher 实例，key 和 watcher 实例可能是 一对多 的关系\n   *   3、如果设置了 immediate，则立即执行 回调函数"},"5":{"objectClass":"MindNode","ID":"QKFS2","text":"   * 其实到这里也能看出，computed 和 watch 在本质是没有区别的，都是通过 watcher 去实现的响应式\n   * 非要说有区别，那也只是在使用方式上的区别，简单来说：\n   *   1、watch：适用于当数据变化时执行异步或者开销较大的操作时使用，即需要长时间等待的操作可以放在 watch 中\n   *   2、computed：其中可以使用异步方法，但是没有任何意义。所以 computed 更适合做一些同步计算"},"objectClass":"NSArray"},"text":"数据响应式的入口：分别处理 props、methods、data、computed、watch\n * 优先级：props、methods、data、computed 对象中的属性不能出现重复，优先级和列出顺序一致\n * 其中 computed 中的 key 不能和 props、data 中的 key 重复，methods 不影响"},"objectClass":"NSArray"},"text":"initState(vm)\n数据响应式的重点，处理 props、methods、data、computed、watch"},"8":{"objectClass":"MindNode","ID":"Y9H8J","text":"initProvide(vm)\n解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上（在处理data/prop之后完成）"},"9":{"objectClass":"MindNode","ID":"SH8AS","text":"callHook(vm, 'created')\n调用 created 钩子函数"},"10":{"objectClass":"MindNode","ID":"39682","text":"    // 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount，反之，没有 el 则必须手动调用 $mount\n    if (vm.$options.el) {\n      // 调用 $mount 方法，进入挂载阶段\n      vm.$mount(vm.$options.el)\n    }","maxWidthLine":348.671875},"objectClass":"NSArray"},"text":"const vm"},"2":{"objectClass":"MindNode","ID":"Z5377","children":{"0":{"objectClass":"MindNode","ID":"61447","text":""},"objectClass":"NSArray"},"text":"总结\n\nVue 的初始化过程（new Vue(options)）都做了什么？\n处理组件配置项\n初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上\n初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率\n初始化组件实例的关系属性，比如 \nparent、\nchildren、root、\nrefs 等\n处理自定义事件\n调用 beforeCreate 钩子函数\n初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上\n数据响应式，处理 props、methods、data、computed、watch 等选项\n解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上\n调用 created 钩子函数\n如果发现配置项上有 el 选项，则自动调用 mount法，也就是说有了选项，就不需要再手动调用\nmount 方法，反之，没提供 el 选项则必须调用 $mount\n接下来则进入挂载阶段\n"},"objectClass":"NSArray"},"text":"initMixin(Vue)\n定义 Vue.prototype._init 方法"},"1":{"objectClass":"MindNode","ID":"37T4G","text":"stateMixin(Vue)\n * 定义：\n *   Vue.prototype.$data\n *   Vue.prototype.$props\n *   Vue.prototype.$set\n *   Vue.prototype.$delete\n *   Vue.prototype.$watch"},"2":{"objectClass":"MindNode","ID":"46F60","text":"eventsMixin(Vue)\n * 定义 事件相关的 方法：\n *   Vue.prototype.$on\n *   Vue.prototype.$once\n *   Vue.prototype.$off\n *   Vue.prototype.$emit"},"3":{"objectClass":"MindNode","ID":"VBOB1","text":"lifecycleMixin(Vue)\n * 定义：\n *   Vue.prototype._update\n *   Vue.prototype.$forceUpdate\n *   Vue.prototype.$destroy"},"4":{"objectClass":"MindNode","ID":"9F81H","text":"\nrenderMixin(Vue)\n * 执行 installRenderHelpers，在 Vue.prototype 对象上安装运行时便利程序\n * \n * 定义：\n *   Vue.prototype.$nextTick\n *   Vue.prototype._render"},"objectClass":"NSArray"},"text":"function Vue"},"ID":"US97Q","style":100,"lineKeepThin":true}